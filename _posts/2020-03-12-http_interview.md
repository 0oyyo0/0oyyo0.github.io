---
layout:     post
title:      http面试总结
subtitle:   http面试总结
date:       2020-03-12
author:     王鹏程
header-img: img/post-bg-ios10.jpg
catalog: true
tags:
    - 计算机网络
    - 后台开发
    - 面试
---

# HTTP面试总结

_参考链接:_

- [firefoxhttp文档](https://developer.mozilla.org/zh-CN/docs/Web/HTTP)
- [HTTPS系列干货（一）：HTTPS 原理详解](https://zhuanlan.zhihu.com/p/27395037)
- [HTTP面试题都在这里](https://zhuanlan.zhihu.com/p/33778904)
- [HTTPS 原理看了很多，这个是最清晰的](https://zhuanlan.zhihu.com/p/101544881)
- [47天时间，洒热血复习](https://zhuanlan.zhihu.com/p/92436722)
- [让面试官膜拜你的HTTPS运行流程（超详细）](https://zhuanlan.zhihu.com/p/60033345)
- [深入理解https进行SSL认证的全过程](https://blog.csdn.net/qq_40733949/article/details/93405054?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task)
- [你连 HTTPS 原理都不懂，还讲“中间人攻击”？](https://blog.csdn.net/h8y0bDJVUkwE1LboZlE/article/details/103798032)(必读)

## 1. Http与Https的区别：
1. HTTP 的URL 以http:// 开头，而HTTPS 的URL 以https:// 开头
2. HTTP 是不安全的，而 HTTPS 是安全的
HTTP 标准端口是80 ，而 HTTPS 的标准端口是443
3. 在OSI 网络模型中，HTTP工作于应用层，而4. HTTPS 的安全传输机制工作在传输层
5. HTTP 无法加密，而HTTPS 对传输的数据进行加密
6. HTTP无需证书，而HTTPS 需要CA机构wosign的颁发的SSL证书


## 2. 什么是Http协议无状态协议?怎么解决Http协议无状态协议?
- 无状态协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息;也就是说，当客户端一次HTTP请求完成以后，客户端再发送一次HTTP请求，HTTP并不知道当前客户端是一个”老用户“。
- 可以使用Cookie来解决无状态的问题，Cookie就相当于一个通行证，第一次访问的时候给客户端发送一个Cookie，当客户端再次来的时候，拿着Cookie(通行证)，那么服务器就知道这个是”老用户“。

## 3. URI和URL的区别

**URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。**

- Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的
- URI一般由三部组成：
    1. 访问资源的命名机制
    2. 存放资源的主机名
    3. 资源自身的名称，由路径表示，着重强调于资源。

**URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。**

- URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。
- 采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成：
    1. 协议(或称为服务方式)
    2. 存有该资源的主机IP地址(有时也包括端口号)
    3. 主机资源的具体地址。如目录和文件名等

**URN，uniform resource name，统一资源命名，是通过名字来标识资源，比如mailto:java-net@java.sun.com。**

- URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。上面的 mailto、news 和 isbn URI 都是 URN 的示例。

## 4. 常用的HTTP方法有哪些？
- GET： 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器
- POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。
- PUT： 传输文件，报文主体中包含文件内容，保存到对应URI位置。
- HEAD： 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。
- DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件。
- OPTIONS：查询相应URI支持的HTTP方法。

注意:http1.0只有GET、POST和HEAD方法

## 5. HTTP请求报文与响应报文格式



![http请求格式如下](https://pic1.zhimg.com/80/v2-c15979b64c06e91dce415a39fa0300a8_720w.jpg)

![请求报文格式](https://pic1.zhimg.com/v2-054ba2c979cd2792840d99a1d0f4dc1c_r.jpg)

- http请求报文
    1. 请求行：包含请求方法、URI、HTTP版本信息
    2. 请求首部字段
    3. 请求内容实体
    4. 空行

![http响应格式](https://pic4.zhimg.com/80/v2-a711c519831c81a1043aea5e7513c34b_720w.jpg)
![http响应格式](https://pic2.zhimg.com/v2-e2447b28c4e1fd60d43bfa3976ff1531_r.jpg)

- http响应报文:
    1. 状态行：包含HTTP版本、状态码、状态码的原因短语
    2. 响应首部字段
    3. 响应内容实体
    4. 空行

### 常见的首部：
- **通用首部字段（请求报文与响应报文都会使用的首部字段）**
    - Date：创建报文时间
    - Connection：连接的管理
    - Cache-Control：缓存的控
    - Transfer-Encoding：报文主体的传输编码方式

- **请求首部字段（请求报文会使用的首部字段）**
    - Host：请求资源所在服务器
    - Accept：可处理的媒体类型
    - Accept-Charset：可接收的字符集
    - Accept-Encoding：可接受的内容编码
    - Accept-Language：可接受的自然语言


- **响应首部字段（响应报文会使用的首部字段）**
    - Accept-Ranges：可接受的字节范围;主要在断点续传中使用
    - Location：令客户端重新定向到的URI
    - Server：HTTP服务器的安装信息


- **实体首部字段（请求报文与响应报文的的实体部分使用的首部字段）**
    - Allow：资源可支持的HTTP方法
    - Content-Type：实体主类的类型
    - Content-Encoding：实体主体适用的编码方式
    - Content-Language：实体主体的自然语言
    - Content-Length：实体主体的的字节数
    - Content-Range：实体主体的位置范围，一般用于发出部分请求时使用


## 6. HTTPS工作原理

https主要工作流程如下:

- 一、首先HTTP请求服务端生成证书，客户端对证书的有效期、合法性、域名是否与请求的域名一致、证书的公钥（RSA加密）等进行校验；
- 二、客户端如果校验通过后，就根据证书的公钥的有效， 生成随机数，随机数使用公钥进行加密（RSA加密）；
- 三、消息体产生的后，对它的摘要进行MD5（或者SHA1）算法加密，此时就得到了RSA签名；
- 四、发送给服务端，此时只有服务端（RSA私钥）能解密。
- 五、解密得到的随机数，再用AES加密，作为密钥（此时的密钥只有客户端和服务端知道）。

## 7. 一次完整的HTTP请求所经历的7个步骤
HTTP通信机制是在一次完整的HTTP通信过程中，Web浏览器与Web服务器之间将完成下列7个步骤：

1. 建立TCP连接:

在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建 Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。**HTTP是比TCP更高层次的应用层协议，根据规则， 只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。**

2. Web浏览器向Web服务器发送请求行

一旦建立了TCP连接，**Web浏览器就会向Web服务器发送请求命令**。例如：GET /sample/hello.jsp HTTP/1.1。

- Web浏览器发送请求头:
    - 浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后**浏览器发送了一空白行来通知服务器**，它已经结束了该头信息的发送。
- Web服务器应答:
    - 客户机向服务器发出请求后，服务器会客户机回送应答， **HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。**
- Web服务器发送应答头:
    - 正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。
- Web服务器向浏览器发送数据:
    - Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，**它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。**
- Web服务器关闭TCP连接:
    - 一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了`Connection:keep-alive`;TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。

总结:建立TCP连接->发送请求行->发送请求头->（到达服务器）发送状态行->发送响应头->发送响应数据->断TCP连接

## 7. HTTP常用的状态码 
_参考链接：_ [常见的HTTP状态码](https://www.cnblogs.com/xflonga/p/9368993.html);[HTTP状态码详解](https://tool.oschina.net/commons?type=5)

### 7.1 三至七种最基本的响应代码

- 200("OK"):一切正常。实体主体中的文档（若存在的话）是某资源的表示。
- 400("Bad Request"):客户端方面的问题。实体主题中的文档（若存在的话）是一个错误消息。希望客户端能够理解此错误消息，并改正问题。
- 500("Internal Server Error"):服务器方面的问题。实体主体中的文档（如果存在的话）是一个错误消息。该错误消息通常无济于事，因为客户端无法修复服务器方面的问题。
- 301("Moved Permanently"):当客户端触发的动作引起了资源URI的变化时发送此响应代码。另外，当客户端向一个资源的旧URI发送请求时，也发送此响应代码。
- 404("Not Found") 和410("Gone"):当客户端所请求的URI不对应于任何资源时，发送此响应代码。404用于服务器端不知道客户端要请求哪个资源的情况；410用于服务器端知道客户端所请求的资源曾经存在，但现在已经不存在了的情况。
- 409("Conflict"):当客户端试图执行一个”会导致一个或多个资源处于不一致状态“的操作时，发送此响应代码。

SOAP Web服务只使用响应代码200("OK")和500("Internal Server Error")。无论是你发给SOAP服务器的数据有问题，还是服务器在处理数据的过程中出现问题，或者SOAP服务器出现内部问题，SOAP服务器均发送500("Internal Server Error")。客户端只有查看SOAP文档主体（body）（其中包含错误的描述）才能获知错误原因。客户端无法仅靠读取响应的前三个字节得知请求成功与否。


- 1xx:通知;仅仅在与HTTP服务器沟通时使用
    - 100("Continue"):继续发送未完的请求数据。(客户端设置Expect为"100-continue")
    - 101("Switching Protocols"):告诉客户端更换协议，协议存放在Upgrade 消息头中。
    - 102:由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。
    - 103 Early Hints:此状态代码主要用于与Link 链接头一起使用，以允许用户代理在服务器仍在准备响应时开始预加载资源。
- 2xx:成功
    - 200("OK"):表示返回请求成功
    - 201("Created"):当服务器依照客户端的请求创建了一个新资源时，发送此响应代码。
    - 202("Accepted"):服务器已接受请求，但尚未处理。
    - 203("Non-Authoritative Information"):服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。
    - 204("No Content"):服务器拒绝对PUT、POST或者DELETE请求返回任何状态信息或表示，那么通常采用此响应代码。表明“客户端请求的资源存在，但其表示是空的”
    - 205("Reset Content"):服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。 　　与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。
    - 206("Partial Content"):它跟200类似，但它用于对部分GET请求（即使用Range请求报头的GET请求）的响应。部分GET请求常用于大型二进制文件的断点续传。
- 3XX 重定向:
    - 300("Multiple Choices"):被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。
    - 301("Moved Permanently"):永久性重定向
    - 302("Found"):临时重定向
    - 303("See Other"):与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上
    - 304("Not Modified"):发送附带条件的请求时，条件不满足时返回，与重定向无关.
    - 305("Use Proxy"):这个响应代码用于告诉客户端它需要再发一次请求，但这次要通过一个HTTP代理发送，而不是直接发送给服务器。
    - 306:最新标准中已经被放弃使用
    - 307("Temporary Redirect"):临时重定向，与302类似，只是强制要求使用POST方法.
- 4XX:客户端错误
    - 400("Bad Request"):1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。 　　2、请求参数有误。
    - 401("Unauthorized"):客户端试图对一个受保护的资源进行操作，却又没有提供正确的认证证书。Authorization 头信息部应该重新发送正确的身份验证
    - 402("Payment Required"):支付需要
    - 403("Forbidden"):客户端请求的结构正确，但是服务器不想处理,它请求的对应资源禁止被访问。这跟证书不正确的情况不同--若证书不正确，应该发送响应代码401。
    - 404("Not Found"):服务器无法找到对应资源.
    - 405("Method Not Allowd"):客户端试图使用一个本资源不支持的HTTP方法。例如：一个资源只支持GET方法，但是客户端使用PUT方法访问。
    - 406("Not Acceptable"):当客户端对表示有太多要求，以至于服务器无法提供满足要求。如请求媒体类型为application/json+hic。但是服务器只支持json
    - 407("Proxy Authentication Required"):只有HTTP代理会发送这个响应代码。它跟401类似，唯一区别在于：这里不是无权访问web服务，而是无权访问代理。
    - 408("Reqeust Timeout"):建立连接之后，不发送任何请求。发送一个408响应代码，准备关闭此连接。
    - 409("Conflict"):由于和被请求的资源的当前状态之间存在冲突，请求无法完成。比如修改权限不允许的资源。
    - 410("Gone"):服务器知道被请求的URI过去曾指向一个资源，但该资源现在不存在了的情况。
    - 411("Length Required"):请求发送正确的 Content-Length请求头部数据。
    - 412("Precondition Failed"):对客户端的请求条件(客户端提供)不满足。不做处理。
    - 413("Request Entity Too Large"):客户端发送的表示太大，以至于服务器无法处理;并请求关闭连接。
    - 414("Request-URI Too Long"):URI长度超过服务器处理上限
    - 415("Unsupported Media Type"):不支持的媒体类型。
    - 416("Requestd Range Not Satisfiable"):客户端所请求的字节范围超出表示的实际大小。
    - 417("Expectation Failed"):在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。
    - 421:客户端所在的IP地址比如用户的网关或者代理服务器地址）到服务器的连接数超过了服务器许可的最大范围
    - 422:请求格式正确，但是由于含有语义错误，无法响应。
    - 424:由于之前的某个请求发生的错误，导致当前请求失败
    - 425:未定义
    - 426:客户端应当切换到TLS/1.0
    - 449:由微软扩展，代表请求应当在执行完适当的操作后进行重试。
- 5XX 服务端错误
    - 500("Internal Server Error"):服务器未知内部错误。
    - 501("Not Implemented"):客户端试图使用一个服务器不支持的HTTP特性。
    - 502("Bad Gateway"):网关或者代理服务器错误。
    - 503("Service Unavailable"):HTTP服务器正常，只是下层web服务服务不能正常工作。表示服务器正在忙。
    - 504("Gateway Timeout"):跟502类似，只有HTTP代理会发送此响应代码。此响应代码表明代理无法连接上行服务器。
    - 505("HTTP Version Not Supported"):服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。
    - 506(Variant Also Negotiates):代表服务器存在内部配置错误
    - 507(Insufficient Storage): 服务器无法存储完成请求所必须的内容。
    - 509:服务器达到带宽限制。
    - 510(Not Extended):客户端需要对请求进一步扩展，服务器才能实现它。服务器会回复客户端发出扩展请求所需的所有信息。
    - 511(Network Authentication Required):状态码指示客户端需要进行身份验证才能获得网络访问权限。

## 8. HTTPS的请求流程：

![HTTPS请求流程](https://pic2.zhimg.com/80/v2-cd198e0929f583fb87cffe9686edf901_720w.jpg)

1. 客户端（浏览器）向服务器请求https连接。
2. 服务器返回证书（公钥）到客户端。
3. 客户端随机的秘钥A（用于对称加密）。
4. 客户端用公钥对A进行加密。
5. 客户端将加密A后的密文发送给服务器。
6. 服务器通过私钥对密文进行解密得到对称加密的秘钥。
7. 客户端与服务器通过对称秘钥加密的密文通信。

上述过程中第2步骤中是存在风险的，因为公钥是暴露出来的，当公钥被中间人非法截获时，同时将公钥替换成中间人自己的公钥发送给客户端，从而得到对称加密的秘钥，进而伪装与客户端通信。

为了解决这种问题，就引入了数字证书与数字签名

所以在第2步骤时，服务器发送了一个SSL证书给客户端，SSL证书中包含了具体的内容有证书的颁发机构、有效期、公钥、证书持有者、签名，通过第三方的校验保证身份的合法。

一、首先客户端会读取证书所有者、有效期等信息进行校验。

二、客户端（浏览器）开始查找操作系统中已内置的受信任的证书发布机构CA，与服务器发过来的证书的颁发CA比对，用于验证证书是否为合法机构颁发。

三、如果找不到，浏览器就会报错。

四、如果找到了，就会取出其中的公钥，对证书内的签名进行解密。

五、使用相同的Hash算法对签名进行去摘要并与服务器发来的摘要进行对比。

六、如果对比一致，则合法，这样就得到公钥了。

## 9. HTTP1.1版本新特性
- a. **默认持久连接节省通信量**，只要客户端服务端任意一端没有明确提出断开TCP连接，就一直保持连接，可以发送多次HTTP请求
- b. **管线化，客户端可以同时发出多个HTTP请求，而不用一个个等待响应**
- c. **断点续传**:实际上就是利用HTTP消息头使用分块传输编码，将实体主体分块传输。

## 10. HTTP优化方案

- **TCP复用**:TCP连接复用是将多个客户端的HTTP请求复用到一个服务器端TCP连接上，而HTTP复用则是一个客户端的多个HTTP请求通过一个TCP连接进行处理。前者是负载均衡设备的独特功能；而后者是HTTP 1.1协议所支持的新功能，目前被大多数浏览器所支持。
- **内容缓存**:将经常用到的内容进行缓存起来，那么客户端就可以直接在内存中获取相应的数据了。
- **压缩**:将文本数据进行压缩，减少带宽
- **SSL加速（SSL Acceleration）**:使用SSL协议对HTTP协议进行加密，在通道内加密并加速。
- **TCP缓冲**:通过采用TCP缓冲技术，可以提高服务器端响应时间和处理效率，减少由于通信链路问题给服务器造成的连接负担。

## 11. HTTP 常用方法

![HTTP常用方法](https://pic1.zhimg.com/80/v2-a1204f1884e4677f2e2fa37b36b85bb8_720w.jpg)

## 12. 本地随机数被窃取怎么办？

证书验证是采用非对称加密实现，但是传输过程是采用对称加密，而其中对称加密算法中重要的随机数是由本地生成并且存储于本地的，HTTPS 如何保证随机数不会被窃取？

其实 HTTPS 并不包含对随机数的安全保证，HTTPS 保证的只是传输过程安全，而随机数存储于本地，本地的安全属于另一安全范畴，应对的措施有安装杀毒软件、反木马、浏览器升级修复漏洞等。



## 13 cookie与session区别

- [cookie 和session 的区别详解](https://www.cnblogs.com/shiyangxt/articles/1305506.html)

cookie机制。正统的cookie分发是通过扩展HTTP协议来实现的，服务器通过在HTTP的响应头中加上一行特殊的指示以提示浏览器按照指示生成相应的cookie。然而纯粹的客户端脚本如JavaScript或者VBScript也可以生成cookie。而cookie的使用是由浏览器按照一定的原则在后台自动发送给服务器的。浏览器检查所有存储的cookie，如果某个cookie所声明的作用范围大于等于将要请求的资源所在的位置，则把该cookie附在请求资源的HTTP请求头上发送给服务器。

session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。

- cookie 和session 的区别：
	- cookie数据存放在客户的浏览器上，session数据放在服务器上。
	- cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗;考虑到安全应当使用session。
	- session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能;考虑到减轻服务器性能方面，应当使用COOKIE。
	- 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。
	- 登陆信息等重要信息存放为SESSION;其他信息如果需要保留，可以放在COOKIE中。
