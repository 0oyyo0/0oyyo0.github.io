---
layout:     post
title:      C++ Primer 学习笔记(八)
subtitle:   C++ Primer 学习记录(八)
date:       2019-05-31
author:     王鹏程
header-img: img/post-bg-ios10.jpg
catalog: true
tags:
    - C++
    - 基础编程
---

## 第15章 面向对象程序设计

### 15.1 oop:概述
面向对象程序设计的核心思想是数据抽象、继承和动态绑定。

**虚函数：** 基类希望它的派生类各自定义适合自身版本，将这些函数声明为**虚函数**；派生类必须通过派生类列表明确指明他是从那个基类继承而来的。即 **基类希望派生类能进行覆盖的函数**

**动态绑定**
通过**动态绑定**，我们能用同一段代码分别处理不同的对象。相同函数，根据动态绑定的对象实质进行区别。在运行时选择函数的版本，所以动态绑定有时又被称为 **运行时绑定**

注意：

- 在c++语言中，当我们使用基类的引用(或者指针)调用一个虚函数时将发生动态绑定。

### 15.2 定义基类和派生类

注意：

- 基类同城都应该定义一个虚析构函数，计时该函数不执行任何实际操作也是如此。
- 如果一个派生类没有覆盖其基类中的某个虚函数，则该函数的行为类似于其他成员，派生类会直接继承其在基类中的版本。
- 同一个对象中，继承自基类的部分和派生类自定义的部分不一定是连续存储的。

```c++
class Quote{
public:
    Quote()=default;
    Quote(const std::string &book,double sales_price):bookNo(book),price(sales_price){}
    std::string isbn() const {return bookNo;}
    //返回给定数量的书籍的销售总额
    
    //派生类负责改写并使用不同的折扣计算算法
    
    virtual double net_price(std::size_t n) const
    {return n*price;}

    virtual ~Quote()=default; //对析构函数进行动态绑定
private:
    std::string bookNo;  //书籍编号

protected:
    double price=0.0   //普通状态下不打折扣的价格 

}

```

可以将派生类的对象当成基类来使用，而且也能将基类的指针或者引用绑定到派生类对象中的基类部分上。

```c++
Quote item;  //基类对象

Bulk_quote bulk;  //派生类对象

Quote *p=&item;  //p指向Quote对象

p=&bulk; //p指向bulk的Quote的部分

Quote &r=bulk;  //r绑定到bulk的Quote部分

```
上述转换可以把派生类对象的指针用在需要基类指针的地方。
注意：

- 在派生类对象中含有与基类对应的组成部分，这一事实是继承的关键。
- 派生类不能直接初始化继承的基类成员，必须使用基类的构造函数来初始化它的基类部分；每个类控制它自己的成员初始化过程。
- 除非我们特别指出，否则派生类的基类部分会像数据成员一样执行默认初始化。如果需要使用基类的构造函数需要，使用`基类名(参数1，参数2)` 的形式进行显式调用。否则进行一般空参数的默认初始化。
- 首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。
-  **c++中类，是在实例化时才会查找相关代码，没有使用就不会生成对应代码，函数无论使用都会生成。**
-  类会自动生成一个`namespace`,其中的静态成员和静态变量，相当于`namespace`中的变量和函数。
-  如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。不论从基类中派生出来多少个派生类，对于每个静态成员来说都只存在唯一的实例。
-  如果我们想要某个类用作基类，则该类函数必须已经定义而非仅仅声明。主要是构造函数和成员变量必须定义，因为子类的构造函数必须使用父类的构造函数。
-  在类后面添加关键字`final`可以有效防止类被继承。
-  和内置指针一样，智能指针类也支持派生类向基类的类型转换，意味着我们可以将一个派生类对象的指针存储在一个基类指针的只能指针内。

**基类和派生类**

不存在基类向派生类的隐式类型转换，但是当编译器无法确定某个特定的转换在运行时是否安全的时候，则可以，但这是很危险的，并且基类函数的析构函数最好是虚析构函数。([C++中虚析构函数的作用](https://www.cnblogs.com/lit10050528/p/3874703.html))

```c++
Bulk_quote bulk;
Quote *itemP=&bulk;  //正确；动态类型是Bulk_quote

Bulk_quote *bulkP=itemP;  //错误，不能将基类转换成派生类

```

派生类向基类的自动类型转换，支队指针或者引用类型有效，在派生类类型和基类类型之间不存在这样的转换。

当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生类部分将被忽略掉。

存在继承关系的类型之间的转换规则

- 从派生类向基类的类型转换只对指针或引用类型有效
- 基类向派生类不存在隐式类型转换
- 和任何其他成员一样，派生类向基类的类型转换也可能会由于访问受限而变得不可行。

### 15.3 虚函数

**虚函数的调用可能在运行时才被解析**

注意：

- 一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数。
- 一个派生类的函数如果覆盖了继承来的虚函数，则它的形参类型必须被它覆盖的基类函数完全一致;返回类型也必须相同。形参列表不同时会产生新的函数，继承的基类函数仍旧有效。
- 使用`override`关键字可以明确重载，原函数中没有函数，或者参数不对应则都会产生错误。
- 如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。

**回避虚函数的机制**

可以使用作用域运算符，实现虚函数的强行绑定，而非动态绑定；例如：

```c++
double undiscounted=baseP->Quote::net_price(42);
//强行调用基类中定义的函数版本而不管baseP的动态类型到底是什么

```

通常情况下，只有成员函数(或者友元)中的代码才需要使用作用域运算符来回避虚函数的机制。通常是一个派生类的虚函数调用它覆盖的基类的虚函数版本时。

注意：如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符，则在运行时该调用将被解析为对派生类版本自身的调用，从而导致无限递归。

### 15.4 抽象基类

含有纯虚函数的类是抽象基类；不能创建抽象基类的对象，只能被继承

重构：负责重新设计类的体系以便将操作或数据从一个类移动到另外一个类中。

### 15.5 访问控制与继承

protect:希望派生类分享但是不想被其他公共访问使用的成员。

- 受保护的成员对于类的用户来说是不可访问的。
- 受保护的成员，对于派生类的成员和友元来说是可以访问的
- 派生类或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类的受保护成员没有任何访问特权。

```c++

```









