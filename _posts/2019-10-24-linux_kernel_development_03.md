---
layout:     post
title:      Linux内核设计与实现 学习笔记 (三)
subtitle:   Linux内核设计与实现 学习笔记 (三)
date:       2019-10-24
author:     王鹏程
header-img: img/post-bg-ios10.jpg
catalog: true
tags:
    - C/C++
    - Linux
    - 操作系统
    - 程序设计
---

> 2019-10-24 20:25:49

# Linux内核设计与实现 学习笔记 (三)

------

## 第 9 章 内核同步介绍

在单处理器时，只有在中断发生的时候，或者在内核代码明确地请求重新调度、执行另外一个任务时，数据才能被访问。

**[Linux多核并行编程关键技术](https://www.cnblogs.com/wahaha02/p/9175637.html)**
- 锁技术： Linux kernel提供了多种锁机制，如自旋锁、信号量、互斥量、读写锁、顺序锁等。各种锁的简单比较如下，具体实现和使用细节这里就不展开了，可以参考《Linux内核设计与实现》等书的相关章节。
  - 自旋锁，不休眠，无进程上下文切换开销，可以用在中断上下文和临界区小的场合；
  - 信号量，会休眠，支持同时多个并发体进入临界区，可以用在可能休眠或者长的临界区的场合；
  - 互斥量，类似与信号量，但只支持同时只有一个并发体进入临界区；
  - 读写锁，支持读并发，写写/读写间互斥，读会延迟写，对读友好，适用读侧重场合；
  - 顺序锁，支持读并发，写写/读写间互斥，写会延迟读，对写友好，适用写侧重场合；<br>
锁技术虽然能有效地提供并行执行下的竞态保护，但锁的并行可扩展性很差，无法充分发挥多核的性能优势。锁的粒度太粗会限制扩展性，粒度太细会导致巨大的系统开销，而且设计难度大，容易造成死锁。除了并发可扩展性差和死锁外，锁还会引入很多其他问题，如锁惊群、活锁、饥饿、不公平锁、优先级反转等。不过也有一些技术手段或指导原则能解决或减轻这些问题的风险。
  - 按统一的顺序使用锁（锁的层次），解决死锁问题；
  - 指数后退，解决活锁/饥饿问题；
  - 范围锁（树状锁），解决锁惊群问题；
  - 优先级继承，解决优先级反转问题；

- 原子技术:原子技术主要是解决cache和内存不一致性和乱序执行对原子访问的破坏问题。Linux kernel中主要的原子原语有：
  - ACCESS_ONCE()、READ_ONCE() and WRITE_ONCE()：禁止编译器对数据访问的优化，强制从内存而不是缓存中获取数据；
  - barrier()：乱序访问内存屏障，限制编译器的乱序优化；
  - smb_wmb()：写内存屏障，刷新store buffer，同时限制编译器和CPU的乱序优化；
  - smb_rmb()：读内存屏障，刷新invalidate queue，同时限制编译器和CPU的乱序优化；
  - smb_mb()：读写内存屏障，同时刷新store buffer和invalidate queue，同时限制编译器和CPU的乱序优化；
  - atomic_inc()/atomic_read()等：整型原子操作；
严格来说，Linux kernel作为系统软件，实现受硬件影响很大，不同硬件有不同的内存模型，因此，不同于高级语言，Linux kernel的原子原语语义并没有一个统一模型。比如在SMP的ARM64 CPU上，barrier、smb_wmb、smb_rmb的实现与smb_mb都是一样的，都是volatile ("" ::: "memory")。
另外，再多提一句的是，atomic_inc()原语为了保证原子性，需要对cache进行刷新，而缓存行在多核体系下传播相当耗时，其多核下的并行可扩展性差。

- 无锁技术:原子技术，是无锁技术中的一种，除此之外，无锁技术还包括RCU、Hazard pointer等。值得一提的是，这些无锁技术都基于内存屏障实现的。
  - Hazard pointer主要用于对象的生命周期管理，类似引用计数，但比引用计数有更好的并行可扩展性；
  - RCU适用的场景很多，其可以替代：读写锁、引用计数、垃圾回收器、等待事物结束等，而且有更好的并行扩展性。但RCU也有一些不适用的场景，如写侧重；临界区长；临界区内休眠等场景。
  - 不过，所有的无锁原语也只能解决读端的并行可扩展性问题，写端的并行可扩展性只能通过数据分割技术来解决。

- 数据分割技术：分割数据结构，减少共享数据，是解决并行可扩展性的根本办法。对分割友好（即并行友好）的数据结构有：
  - 数组
  - 哈希表
  - 基树（Radix Tree）/稀疏数组
  - 跳跃列表（skip list）<br>
使用这些便于分割的数据结构，有利于我们通过数据分割来改善并行可扩展性。
除了使用合适的数据结构外，合理的分割指导规则也很重要：
  - 读写分割：以读为主的数据与以写为主的数据分开；
  - 路径分割：按独立的代码执行路径来分割数据；
  - 专项分割：把经常更新的数据绑定到指定的CPU/线程中；
  - 所有权分割：按CPU/线程个数对数据结构进行分割，把数据分割到per-cpu/per-thread中；
4种分割规则中，所有权分割是分割最彻底的。

以上这些多核并行编程内容基本上涵盖了Linux kernel中所有的并发编程关键技术。当然并行编程还有很多其他技术没有应用到Linux kernel中的，如无副作用的并行函数式编程技术（Erlang/Go等）、消息传递、MapReduce等等。

### 9.1 临界区和竞争条件

- 临界区:访问和共享数据操作的代码段；
- 同步:避免并发和防止竞争条件；
- 执行线程:所有正在执行的代码实例的总称。

处理器一般都提供对数据访问的原子操作。来防止数据的乱序

### 9.2 加锁

锁强制确保一次有且只有一个线程对数据结构进行操作，或者禁止其它访问。

![线程锁操作](../img/2019-10-24-21-50-10.png)

锁是使用原子操作实现的，而原子操作不存在竞争。

#### 9.2.1 造成并发执行的原因 

用户空间之所以需要同步；是因为用户程序会被调度程序抢占和重新调度。因为单核系统中线程之间是相互交叉进行的，因此也可以称为伪并发进行。

内核中并发执行的原因：中断、软中断和tasklet、内核抢占、睡眠及用户空间的同步、对称多处理。

注意：两个处理器绝对不能同时访问同一共享数据。

#### 9.2.2 了解要保护什么

在Linux 内核编译时,可以配置CONFIG_SMP配置选项控制内核是否支持SMP.当期没有被设置时就不会被编入不必要的代码.

### 9.3 死锁

死锁产生的条件和避免手段,请参照往期博客.
