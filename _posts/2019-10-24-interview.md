---
layout:     post
title:      武海拾遗录
subtitle:   面试问题与知识点
date:       2019-10-24
author:     王鹏程
header-img: img/post-bg-ios10.jpg
catalog: true
tags:
    - 面经
    - 考试
---

> 2019-10-24 20:25:49


这篇文章主要是各方面零散问题的日常收集

# C++ 

1. 类指针指向实例化对象；在这个对象程序的运行过程中，程序崩溃，发现是这个类指针的虚函数表被破坏了;如何定位这个问题。
> 2019-10-31 09:53:40
_参考链接：_ [腾讯实习生面试，这两道题目该怎么回答](https://www.zhihu.com/question/43416744/answer/95944740);[虚函数、虚表的生成，虚表的修改](https://blog.csdn.net/alegriabaile/article/details/100169837);[C++虚函数表详细解释及实例分析](https://blog.csdn.net/leo115/article/details/8035078)

可能的情况和答案：

C++可以改变指针指向的虚表，但不能改变虚表里面的内容，即虚函数的地址。virtual table在Linux下GCC4.9的实现就是放在read only段.rodata。因此最大的可能性是存在，内存溢出，其它地方发生了修改。使用gdb和Valgrind进行调试复现.也可能是写内存时越界了，破坏了虚函数表

linux是放在只读区，windows是放在全局静态区，windows下可能出现这种情况。

所以只有可能是虚函数表指针被修改了。因此，对象崩溃的可能原因有下面几个:([原文链接](https://www.zhihu.com/question/43416744/answer/95560471))

1. 访问对象时，对象的构造函数尚未执行完毕。
   
多线程调用时，第一个线程会等待instance的构造函数执行完毕后再返回instance的地址，但由于static的存在，instance的构造函数只会执行一次，如果instance的构造函数尚未执行完毕，有第二个线程使用了GetInstance()函数，此时便会访问一个尚未构造完成的对象。（Ps：据说新的C++标准修复了这个问题，但至少VS2013中这个问题是存在的。）这个错误会造成程序中断，此时直接根据函数调用堆栈定位到出错的指针或对象即可。

2. 访问对象前，某处代码手动执行了对象的析构函数。

在多态的情况下，手动调用对象的析构函数，虽然对象的内存并不会被释放，但成员变量中的指针会变为野指针，此时访问它们自然会造成程序崩溃。此外，执行析构函数时，C++还会做一些额外的工作：当执行完派生类的析构函数后，C++会将对象的虚函数表指针从派生类的虚函数表指向基类的虚函数表，因此，虽然派生类的内存空间还没有被释放，但此时已经无法再访问派生类中定义的虚函数了。
这个错误会造成程序中断，此时直接根据函数调用堆栈定位到出错的指针或对象即可。

3. 内存越界访问

虚函数表指针是由编译器管理的，正常情况下开发者不会访问或修改它的值。因此，若虚函数表指针被破坏了，说明程序中发生了内存越界访问，造成了虚函数表指针被意外修改。这个错误虽然会造成程序中断，但出错的位置往往不是错误发生的位置：A. 如果对象不是通过new创建的此时需要排查出错对象声明处的代码，观察在它附近声明的对象是否发生了内存越界访问。（尤其要关注数组对象，内存越界访问通常是由于数组下标越界导致的）。B. 如果对象是通过new创建的此时需要排查整个程序中所有的指针是否发生了越界访问（仍然优先关注数组）。一种做法是重载new / delete操作符，分配内存时在返回的内存前后各自多分配一个int作为首尾标记，并将它们各自设定为一个特殊的值。每次释放内存时，检查首尾标记的值是否合法。如果不合法，说明该内存指针发生了越界访问。

对于C++岗位来说，把汇编弄弄明白；修修GCC或者LLVM的bug；参加参加GSoC。到时候随便飘点calling convention，vectorization，devirtualization，LTO，搞好气场震慑欺软怕硬的傻逼很重要。虚表更是不在话下，你可以反问面试官“你看你对虚表这么热情啊，你知不知道multiple inheritance虚表怎么实现的？static_cast此种情况又是怎么实现的？virtual inheritance又是怎么实现的？知道multiple dispatch么？怎么在C++里用模拟实现unbounded multiple dispatch或者bounded multiple dispatch（std::experimental::variant<>::visit）？不知道不要紧，我给您讲讲”。其实这些虚表实现细节只要老实巴交地读点wiki page就行了。

作者：Tim Shen
链接：https://www.zhihu.com/question/43416744/answer/95524998
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
# 操作系统



# 多线程与并行编程

1. 请问单核机器上写多线程程序，是否需要考虑加锁，为什么？
> 2019-10-24 21:19:48

参考链接:
- [多线程程序在多核和单核上运行的不同](https://blog.csdn.net/ZIV555/article/details/52036841);
- [请问单核机器上写多线程程序](https://blog.csdn.net/N1314N/article/details/93652404);
- [多线程在单核cpu与多核cpu下如何工作](https://blog.csdn.net/qq_28397259/article/details/80810731)

答：在单核机器上写多线程程序，仍然需要线程锁。因为线程锁通常用来实现线程的同步和通信。在单核机器上的多线程程序，仍然存在线程同步的问题。因为在抢占式操作系统中，通常为每个线程分配一个时间片，当某个线程时间片耗尽时，操作系统会将其挂起，然后运行另一个线程。如果这两个线程共享某些数据，不使用线程锁的前提下，可能会导致共享数据修改引起冲突。

在单核上，多个线程执行锁或者临界区时，实际上只有一个线程在执行临界区代码，而核心也只支持一个线程执行，因此不存在冲突。如果某个线程持有锁，那只有其他线程不会被调度到CPU上执行，影响的只是持有和释放锁的时间，处理器时刻在运行着。但是在多核上运行时，锁或临界区会导致其余处理器空闲而只允许一个处理器执行持有锁的那个线程，这是一个串行的过程，会影响性能。

2. 在多线程和大量并发环境下，如果有一个平均运行一百万次出现一次的bug， 你如何调试这个bug(PS:这个bug很难重现，这个时候你要怎么处理或者重现呢)
> 2019-10-31 09:53:40

作者：大丶便一箩筐
链接：https://www.zhihu.com/question/43416744/answer/95560471
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

引发bug的可能性有很多，形形色色的debug方法也有很多，它们各有各的优势，并不存在通用的最优解，我目前用过的调试方法有下面几种：

1. 人肉调试：对于某些bug，直接根据程序的异常表现，就可以知道问题代码的具体位置，心里逆推演一下相关代码，就可以找到问题产生的原因。例：刚给客户端加了个多线程模块，F5运行，等了30s。。。咦？客户端界面怎么还没显示出来？任务管理器一看，客户端进程CPU占用为0：八成是刚写的代码死锁了，直接Review代码吧。
2. 中断调试依赖于IDE的调试方法（写C++一般用的都是VS吧），在可能出问题的代码位置打个断点，或者等程序自己出异常中断，或者手动加判断中断。程序中断后，追溯函数调用堆栈，找到产生异常数据的代码。这是最方便的定位bug的方法，但前提是能够在开发环境重现bug。例：策划突然跑过来说：“新做的技能怎么没伤害啊，是不是代码里的伤害计算公式写错了？balabalabala”。。。计算技能伤害的代码位置打个断点，一看数据，有个乘积因子加载以后的数值是0，“卧槽，你自己回去查下技能表是不是漏填了数据。” 
3. Log调试在经常出错、或极有可能出错的代码位置打印log，从而定位问题的原因。如果bug产生的代码没有被log覆盖到，可以通过临时log排查可能导致出错的问题模块。例：测试：“刚发布的测试客户端怎么XX界面打不开啊，程序看下呗！”程序猿：“log文件发过来”。看完log：“界面里有个资源文件找不到，是不是美术没上传到SVN？”
4. Dump调试利用Windows API，在程序运行不正常时中断，将此时的程序的内存镜像输出到一个dump文件里，然后利用WinDbg获取中断时的函数调用堆栈，从而定位出bug的代码，使用的前提是bug不会导致程序闪退，否则无法保存dump文件。例：客服：“刚才有外网玩家反映切换地图的时候程序报错了。”程序猿：“有dump文件吗？”。分析完客服收集的dump文件：“new内存的时候失败了，加个内存池吧。”
5. 工具调试除了上面几种通用的调试方法以外，对于某些特定的问题，可以使用特定的工具进行调试。例：PIX可以用来调试着色器；LeakDiag可以用来调试内存泄漏；Vtune可以用来调试性能。Ps：由于这些工具通常会对程序性能产生比较明显的影响，大型程序（比如游戏引擎）通常会直接在代码层面集成相应的模块，并通过log将结果打印出来。

上面的五种方法基本是按照使用的困难程度升序排列的，对于具体的bug，在可以解决问题的情况下采用难度最低的debug方法才是最优解。而题目没有给出bug的具体表现，所以这是一个开放性问题。
不过根据问题的四个关键词：
- 关键词一、 “多线程”
- 关键词二、 “大量并发”
- 关键词三、 “一百万次出现一次”
- 关键词四、“很难重现”

可以看出面试官为这个bug设定的属性是：
- 很难定位
- 几乎不可能在开发环境中重现

那么基本可以pass掉人肉调试、中断调试和工具调试。所以此时只能通过收集外网环境中log或者dump文件来分析。

Ps：产生bug的原因有很多，问题中并没给出bug的具体表现，根本没有办法判断bug产生的具体原因。题主和部分答主将答题思路往“临界区”与“多线程同步”之类的方向靠，我觉得有点答非所问了，毕竟面试官的问题不是“造成bug的原因”，而是“如何debug”。

1. 在一个几十万行的程序中，O0没有问题，但是O3挂了，然而在某一个地方加入一条printf就过了。
> 2019-10-31 09:53:40

多线程时间同步问题，O0时，编译器没有开启乱序选项，所有都顺序执行，关键信号和锁能在时间上对应。当开启O3时，编译器执行生成CPU乱序指令，造成线程同步不及时；添加printf后造成了时间延迟。同步灭有问题。多线程冲突，因为输出占用的线程时间避免了冲突.
----


# 数据库

# 网络编程

# 数据结构与算法

# 