---
layout:     post
title:      百度后台电话面准备
subtitle:   2020寒假实习
date:       2019-12-17
author:     王鹏程
header-img: img/post-bg-ios10.jpg
catalog: true
tags:
    - 寒假实习
    - 后台开发
    - 简历投递
    - 百度
---

# 1. C++ 基础

## 1.1 说一下static关键字的作用

1. 全局静态变量
	- 在全局变量前加上关键字static，全局变量就定义成一个全局静态变量.
	- 内存中的位置：静态存储区，在整个程序运行期间一直存在。
	- 初始化：未经初始化的全局静态变量会被自动初始化为0（对于自动对象,如果没有显示初始化,会调用零参数构造函数,如不存在则编译失败);
	- 作用域：**全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。**
2. 局部静态变量
	- 在局部变量之前加上关键字`static`，局部变量就成为一个局部静态变量。
	- 内存中的位置：静态存储区
	- 初始化：未经初始化的全局静态变量会被自动初始化为`0`(对于自动对象,如果没有显示初始化,会调用零参数构造函数,如不存在则编译失败)；
	- 作用域：作用域仍为局部作用域，
		- 当定义它的函数或者语句块结束的时候，作用域结束。
		- 但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；

	---
	- `C语言`中局部静态变量不能使用变量进行初始化的, 因为它在编译期间就被编译器初始化了.
	- `C++`因为引入了对象,必须调用构造函数,所以编译器把对局部静态变量的初始化推迟至第一次调用之前,也就是可以使用变量进行初始化.

	---

3. 静态函数
	- 在函数返回类型前加static，函数就定义为静态函数。**函数的定义和声明在默认情况下都是extern的**，但**静态函数只是在声明他的文件当中可见，不能被其他文件所用**。
	- 函数的实现使用static修饰，**那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；**
	- warning：不要再头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰；

4.  类的静态成员
	- 在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。
	- 因此，**静态成员是类的所有对象中共享的成员，而不是某个对象的成员**。对多个对象来说，静态数据成员只存储一处，供所有对象共用

5. 类的静态函数
	- **静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员**。因此，对静态成员的引用不需要用对象名。
	- **在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）**。*如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：<类名>::<静态成员函数名>(<参数表>);*
	- 不能被virtual修饰,静态成员函数没有this 指针，虚函数的实现是为每一个对象分配一个vptr 指针，而vptr 是通过this 指针调用的，所以不能为virtual；虚函数的调用关系，this->vptr->ctable->virtual function

## 1.2 `C++`和`c`的区别

- 设计思想上：
	- `C++`是面向对象(封装, 继承, 多态)的语言，而C是面向过程的结构化编程语言
	- C中的函数编译时不会保留形参列表, 也不能重载; 而C++中的函数在编译时会保留形参列表, 有重载
- 语法上：
	- `C++`具有`封装`、`继承`和`多态`三种特性
	- `C++`相比`C`，增加许多类型安全的功能，比如强制类型转换、
	- `C++`支持范式编程，比如模板类、函数模板等
- 具体的:
	- 动态管理内存的方法不一样: `malloc/free` 和 `new/delete`
	- struct
		- C中: struct是自定义数据类型; 是变量的集合, 不能添加拥有成员函数; 没有访问权限控制的概念; 结构体名称不能作为参数类型使用, 必须在其前加上struct才能作为参数类型
		- C++中: struct是抽象数据类型, 是一个特殊的类, 可以有成员函数, 默认访问权限和继承权限都是public, 结构体名可以作为参数类型使用
	- C语言没有引用的概念, 更没有左值引用, 右值引用
	- C语言不允许只读数据(const修饰)用作下标定义数组, C++允许
	- C语言的局部静态变量初始化发生于编译时，所以在函数中不能使用变量对局部静态变量进行初始化， 而C++因为增加了对象的概念，而对象需要调用构造函数进行初始化，所以编译器将局部静态变量的初始化推迟至该变量使用之前，也就是说可以使用变量来初始化局部静态变量。

---
- 参考: [2019-11-26-面经汇总-C++基础再探-c和c++的区别](https://zhaostu4.github.io/2019/11/28/%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB-C++%E5%9F%BA%E7%A1%80%E5%86%8D%E6%8E%A2/#59%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9c-%E5%92%8Cc%E7%9A%84%E7%9C%8B%E6%B3%95c-%E5%92%8Cc%E7%9A%84%E5%8C%BA%E5%88%AB)

---
## 1.3 `c++`中四种`cast`转换

> `C++`中四种类型转换是：`static_cast`, `dynamic_cast`, `const_cast`, `reinterpret_cast`

- `const_cast`: 
	- 用来移除`const`或`volatile` 属性。但需要特别注意的是`const_cast`不是用于去除变量的常量性，而是去除**指向常数对象的指针或引用**的常量性，其去除常量性的对象必须为**指针或引用**。
	- 如果对一个指向常量的指针,通过`const_cast`移除`const`属性, 然后进行修改, 编译通过,但是运行时会报段错误
- `static_cast`: 静态类型转换(不能移除`const/volatile`属性)是最常看到的类型转换, 几个功能. 
	- **内置类型之间的转换**, 精度耗损需要有程序员把握
	- **继承体系中的上下行转换**(上行:子类转父类,安全转换; 下行:父类转子类, 不安全转换)
	- **指针类型转换**: `空指针转换成目标类型的空指针`, `把任何类型转换成void 类型`。
- `dynamic_cast`: 主要用在继承体系中的安全向下转型
	- 它能安全地将指向基类的`指针/引用`转型为指向子类的`指针/引用`, 转型失败会返回`null`(转型对象为指针时)或抛出异常`bad_cast`(转型对象为引用时)。
	- `dynamic_cast` 会利用运行时的信息`(RTTI)`来进行动态类型检查，因此dynamic_cast 存在一定的效率损失。
	- 而且`dynamic_cast`进行动态类型检查时, 利用了虚表中的信息, 所以只能用于函数虚函数的类对象中. 
- `reinterpret_cast` 强制类型转换,**非常不安全**
	- 它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针(先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值)。

***
- 参考: 
	- [C++开发必看 四种强制类型转换的总结](https://www.cnblogs.com/lidabo/p/3651049.html)
	- [C++系列总结——volatile关键字](https://www.cnblogs.com/yizui/archive/2019/03/30/10628020.html)
	
	- [2019-11-26-面经汇总-C++基础再探-C++类型转换有四种](https://zhaostu4.github.io/2019/11/28/%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB-C++%E5%9F%BA%E7%A1%80%E5%86%8D%E6%8E%A2/#93c%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%9C%89%E5%9B%9B%E7%A7%8D)

***

## 1.4 C/C++ 中指针和引用的区别
- 初始化:
	- 引用在定义的时候必须进行初始化，并且不能够改变
	- 指针在定义的时候不一定要初始化，并且指向的空间可变

- 访问逻辑不同:
	- 通过指针访问对象, 用户需要使用间接访问
	- 通过引用访问对象, 用户只需使用直接访问, 编译器负责将其处理为间接访问

- 运算结果不同:
	- 自增运算结果不同
	- `sizeof`运算的结果不同
	- 下标运算: 
		- 指针通过下标运算结果是指针所指值为基地址加上偏移, 且基地址可变.
		- 引用通过下标运算结果是引用的是数组才能有这个操作.
	- 函数参数:
		- 传指针的实质是传值，传递的值是指针内储存的变量地址；
		- 传引用的实质是传地址，传递的是变量的地址。
	- 多级: 有多级指针，但是没有多级引用，只能有一级引用。


***
- 参考: 
	- [C++ 引用占用内存？ - toyijiu的专栏 - CSDN博客](https://blog.csdn.net/toyijiu/article/details/99729949)
	- [浅谈返回函数内部new分配的内存的引用_C 语言_脚本之家](https://www.jb51.net/article/100823.htm)
	- [2019-11-26-面经汇总-C++基础再探-1、引用和指针的区别？](https://zhaostu4.github.io/2019/11/28/%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB-C++%E5%9F%BA%E7%A1%80%E5%86%8D%E6%8E%A2/#1%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB)

***

## 1.5 C++中的四个智能指针

- 为什么要使用智慧指针
	- 智慧指针的作用是管理指针,因为在堆上申请的内存空间,是需要手动释放的,如果未释放就会造成内存泄漏,而智慧指针的使用可以很大程度的避免这个问题. 
	- 因为使用智慧指针管理内存的本质是: 栈对象管理堆内存, 而栈对象是超出作用域或者程序意外终止,都会自动调用析构函数,而智慧指针的析构函数会自动释放资源,从而避免内存泄漏. 
	- `RAII`:资源获取就是初始化
- `auto_ptr`: 采用所有权模式, 但是其允许所有权剥离,所以有内存崩溃的风险, 在`c++11`中已经放弃了。
- `unique_ptr`:采用独占式拥有,保证同一时间只有一个智慧指针可以指向该对象. `unique_ptr`不允许所有权剥离,除非本身是临时变量或者使用move指令. 
- `shared_ptr`:采用共享式拥有,多个共享指针可以指向相同的对象,该对象和其相关的资源会在`最后一个共享指针`被销毁时释放. 注意`shared_ptr`有交叉引用相互锁死的问题,即两个对象相互持有对方的共享指针, 造成用不释放的问题
- `weak_ptr`: 是一种不控制对象生命周期的智慧指针,他是共享指针的附属品, 主要是为了避免`shared_ptr`的死锁问题,具体表现为`weak_ptr`只能从`shared_ptr`或另一个`weak_ptr`构造,持有它不会造成`shared_ptr`的引用计数增加,以及并不能通过`weak_ptr`直接访问推向.

## 1.6 野指针是什么

- 野指针就是一个指向**已删除的对象** 或者 为**申请访问受限内存区域**的指针(指针未初始化)

## 1.7 智慧指针内存泄漏的情况
- 当两个对象使用`shared_ptr`相互引用,就会使计数器失效,从而导致内存泄漏,解决方案是使用`weak_ptr`打破循环引用

## 1.8 什么情况下会发生segmet
1. 堆栈溢出
2. 非法的数据修改;如static上的数据
3. 访问了不存在的内存
4. 内存越界，数组越界，变量类型不一致等。
可以使用gdb进行调试修改

## 1.9 为什么析构函数必须是虚函数? 为什么C++默认的析构函数不是虚函数
- 将可能被继承的基类的析构函数设置为虚函数,可以保证当我们使用基类指针指向派生类对象时,依旧可以正常的`delete`, 不至于引起内存泄漏.
- 在类中定义虚函数会增加额外的开销,包括虚函数表和虚表指针,对于非基类而言,构造函数如果设置为虚函数会浪费内存.

## 1.10 `C++` 中的析构函数的作用
- 析构函数名与类名相同,只是在函数名前增加了取反符号`~`以区别于构造函数,其不带任何参数, 也没有返回值.  也不允许重载. 
- 析构函数与构造函数的相反, 当对象生命周期结束的时候,如对象所在函数被调用完毕时,析构函数负责结束对象的生命周期. **注意如果类对象中分配了堆内存一定要在析构函数中进行释放.** 
- 和拷贝构造函数类似,如果用户未定义析构函数, 编译器**并不是一定**会自动合成析构函数, 只有在**成员变量或则基类**拥有析构函数的情况下它才会自动合成析构函数. 
- 如果**成员变量或则基类**拥有析构函数, 则编译器一定会合成析构函数, 负责调用成员变量或则基类的析构函数, 此时如果用户提供了析构函数,则编译器会在用户析构函数之后添加上述代码.
- 类析构的顺序为: 派生类析构函数, 对象成员析构函数, 基类析构函数. 

## 1.11 C++中自动添加构造函数的情况

1. 包含有带默认构造函数的对象成员的类(**某成员变量为带默认构造函数的类的对象**)：
   - 若一个类X没有定义任何构造函数，但却包含一个或以上定义有默认构造函数的对象成员，此时编译器会为X合成默认构造函数，该默认函数会调用对象成员的默认构造函数为之初始化。
   - 如果对象的成员没有定义默认构造函数，那么编译器合成的默认构造函数将不会为之提供初始化。
2. 继承自带有默认构造函数的基类的类(**基类带有默认构造函数**)
3. 带有虚函数(**来自声明或继承**):因为它多了一个vptr，而vptr的设置是由编译器完成的，**因此编译器会为类的每个构造函数添加代码来完成对vptr的初始化。***
4. 带有一个虚基类的类:在这种情况下，编译器要将虚基类在类中的位置准备妥当，提供支持虚基类的机制。也就是说要在所有构造函数中加入实现前述功能的的代码。**没有构造函数将合成默认构造函数。**

## 1.12 编译器合成拷贝构造函数的情况

- 编译器在必要的时候会合成拷贝构造函数：**必要的时刻是指编译器在普通手段无法完成解决“当一个类对象以另一个同类实体作为初值”时，才会合成拷贝构造函数。也就是说，当常规武器能解决问题的时候，就没必要动用非常规武器。**
- 如果**一个类没有定义拷贝构造函数，通常按照“成员逐一初始化(Default Memberwise Initialization)”的手法来解决“一个类对象以另一个同类实体作为初值”.**
- **成员逐一初始化(Default Memberwise Initialization)具体的实现方式则是位逐次拷贝（Bitwise copy semantics）**[^6]。[^6]: Bitwise copy semantics 是Default Memberwise Intializiation的具体实现方式。[别人的解释]

下面是没有定义时默认合成的情况：
1. 类**内含一个声明有拷贝构造函数成员对象**(不论是设计者定义的还是编译器合成的）。
2. 类**继承自一个声明有拷贝构造函数的类**（不论拷贝构造函数是被显示声明还是由编译器合成的）。
3. 类中**声明有虚函数**。
4. 当类的派生串链中**包含有一个或多个虚基类**。

## 1.13 重载和覆盖
- [C++中重载、重写（覆盖）和隐藏的区别](https://blog.csdn.net/zx3517288/article/details/48976097)
- **重载**: 同一可访问区域内声明了多个具有不同参数列表的同名函数, 根据参数列表确定那个函数被调用, 重载不关心函数返回类型. 
- **覆盖/重写**: 是指派生类中重新定义了基类中的`virtual`函数. 其函数名，参数列表，返回值类型，所有都与基类中被重写的函数一致。派生类对象通过**派生类指针或则基类指针**调用时都会调用派生类的重写函数。
- **隐藏**：是指派生类的函数屏蔽了与其同名的基类函数，只要函数名相同，基类函数都会被隐藏. 不管参数列表是否相同。

***
- 重载和重写的区别：
	1) 范围区别：重写和被重写的函数在不同的类中，重载和被重载的函数在同一类中。
	2) 参数区别：重写与被重写的函数参数列表一定相同，重载和被重载的函数参数列表一定不同。
	3) `virtual`区别：重写的基类必须要有`virtual`修饰，重载函数和被重载函数可以被`virtual`修饰，也可以没有。
- 隐藏和重写，重载的区别：
	1) 与重载范围不同：隐藏函数和被隐藏函数在不同类中。
	2) 参数的区别：隐藏函数和被隐藏函数参数列表可以相同，也可以不同，但函数名一定同；

## 1.14 在main()之前执行前运行
- 使用`static`lambda函数：
```cpp
//关闭流输出
static auto static_lambda = []()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    return 0;
}();
```
- `GCC`编译器
```cpp
	// 在main之前
	__attribute((constructor)) void before_main(){
		printf("befor\n");
	}
	// 在main之后
	__attribute((deconstructor)) void after_main(){
		printf("befor\n");
	}
```

## 1.15 字面值常量和左右值
- 简述四行代码的区别
	```c
	const char* arr = "123"; // "123" 为字符串类型字面值, 其储存于常量区, 其值不可修改, arr表示一个指向字符串类型的const指针, 如果试图通过此指针修改字符串的指,编译器会组织这一行为,导致编译失败
	char * brr = "123"; // "123" 为字符串类型字面值, 其储存于常量区, 其值不可修改, brr表示一个指向字符串类型的指针, 这里潜在的逻辑错误, 当我们试图通过brr修改所指向的字符串时, 编译器并不会阻止这一行为, 可编译通过, 但是运行时候,可能发生 DEADLYSIGNAL(致命错误)
	const char crr[] = "123" // 声明了一个以"123"为初值的常量数组, 通常情况下应该是存在于栈区, 但是使用了const修饰,编译器可能会将其放在常量区
	char drr[] = "123"; // 声明了一个以"123"为初值的字符串数组, 应该是储存于栈区, 可通过drr对数组进行修改
	```

***
- [C/C++的四大内存分区和常量的存储位置](https://blog.csdn.net/weixin_30312557/article/details/96680356)
- `std::forward`的作用: [C++完美转发为什么必须要有std::forward](https://www.zhihu.com/question/48367350)
- 左值右值的区别: [C++中的左值与右值(二)](https://www.cnblogs.com/niuxichuan/p/5844109.html)

***

## 1.16 `C++`如何处理返回值
- 函数的返回值用于初始化在调用函数时创建的临时对象:
	1) 返回值为非引用类型：会将函数的返回值复制给临时对象。
	2) 返回值为引用类型：没有复制返回值，返回的是对象本身。(但是不能返回局部变量的引用, 可以是主函数以引用方式传递的对象,或则是堆对象的引用-堆对象的引用可能会造成内存溢出)

- 关于返回值: 
	- 如果 `返回值 <= 4字节`，则返回值通过寄存器`eax`带回。
	- 如果 `4< 返回值 <=8字节`，则返回值通过两个寄存器`eax`和`edx`带回。
	- 如果 `返回值 > 8字节`，则返回值通过产生的临时量带回。