---
layout:     post
title:      C++ Primer 学习笔记(十)
subtitle:   C++ Primer 学习记录(十)
date:       2019-06-15
author:     王鹏程
header-img: img/post-bg-ios10.jpg
catalog: true
tags:
    - C++
    - 基础编程
---


> 2019-06-15 21:38:56 

## 第18章 用于大型程序的工具

### 18.1 异常处理

_参考链接：_ [C++异常处理（try catch）从入门到精通](http://c.biancheng.net/cplus/exception/);

注意： 

- 一个异常如果没有被捕获，则它将终止当前的程序
- 在钱展开的过程中，运行类类型的局部叶象的析构函数，因为这些析构函数是自动执行的，所以它们不应该抛出异常_一旦在钱展开的过程中析构函数抛出了异常，并且析构函数自身没能捕获到该异常，则程序将被终止。
- 抛出指针要求在任何时应的处理代码存在的地方，指针所指的对象都必须存在。
- 通常情况下，如果catch接收的异常与额某个继承体系有关，则最好将该catch的参数定义成类型引用
- 如果在多个catch语句的类型之间存在着继承关系，则我们应该把继承链最底端的类(most derived type )放在前面，而将继承链最顶端的类(least derivedtype)放在后面。

异常类型和catch声明的类型是精确匹配的：

- 允许从非常量向常量的类型转换
- 允许派生类向基类的转换
- 数组被转换成指向数组(元素)类型的指针，函数被转换成指向该函数类型的指针。
- 处理构造函数初始值异常的唯一方法是讲构造函数写成try语句块

`catch(...)`可以匹配任意的异常类型。其通常与重新抛出语句一起使用，其中catch执行当前局部能完成的工作，随后重新抛出异常;当其与其它几个`catch`语句一起出现的时候，必须放在最后否则后面的语句永远不会被执行。

```c++
void manip(){
    try{
        //这里的操作将引发并抛出一个异常
    }
    catch (...){
        //处理异常的某些特殊操作
        
        throw;
    }
}
```

注意： 由于构造函数执行的时候，try语句可能还未能成功初始化，所以不能正常的抛出异常。我们必须将构造函数携程 **函数try语句块**的形式。才能正真使用。例：

```c++
temlate <typename T>
Blob<T>::Blob(std::initializer_list<T> il) try :
    data(std::make_shared<std::vector<T>>(il)){
        // 函数体
        
    } catch (const std:bad_alloc &e){handle_out_of_memory(e);}

```
##### 18.1.4 noexcept 异常说明

C++11新标准中，可以通过提供noexceot说明，指定某个函数不会抛出异常。使用时关键字紧跟函数的参数列表后面。

```c++
void recoup(int) noexcept; //不会抛出异常

void alloc(int);  //可能抛出异常

```

注意：

- 通常情况下，编译器不能也不必在编译时验证异常说明。
- noexcept有两层含义:当跟在函数参数列表后面时它是异常说明符;而当作为noexcept异常说明的bool实参出现时，它是一个运算符。

##### 18.1.5 异常类层次

![异常层次图](../img/error.png)

### 18.2 命名空间

#### 18.2.2 命名空间的定义
```
namespcae cplusplus_primer{
    ...
}
```

注意：

- 命名空间作用域后面无须分号。
- 命名空间可以是不连续的
    + 命名空间的部分成员的作川是定义类，以及声明作为类接口的函数及对象，则这}l L成员应该置J几头文件中，这}l-L,头文件将被包含在使用了这些成员的文件中。
    + 命名空间成员的z义部分则置于另外的源文件中。
    + 在程序III某此实体只能定义一次:如非内联函数、静态数据成员、变量等。
- 定义多个类型不相关的命名空间应该使用单独的文件分别表示每个类型(或关联类型构成的集合)。
- 对于多个命名空间使用时可以使用`::spcaename::subspacename`的方式来寻找命名空间。
- 模板特例化必须定义在原始模板所属的命名空间中。



